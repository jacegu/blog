2011-03-08 11:00+02:00

February Kata: Roman Numerals

Katacast showing the implementantion of the Roman Numerals kata in Ruby with RSpec and Autotest. My february katacast for the 12 months 12 katas initiative.

%p Well, although a little bit late (it's been a hell of a month), here we go again with another katacast.

%p The <a href="https://github.com/12meses12katas/Febrero-Roman-Numerals" >february kata</a> was Roman Numerals. It had two parts but I've only recorded the first one: transforming arabic to roman numerals.<!--more-->

%iframe(src="http://player.vimeo.com/video/20765638" frameborder="0" class="vimeo")

%p
  I have to tell that I'm not as happy with the result as I was with the String Calculator one. Maybe I should have practice it more. Maybe not. Anyway there are a few times during the Kata that I feel that I'm taking too long steps:

%ul>
  %li
    %p
      %u When I refactor to the recursive solution after passing the <code>III</code> spec:
    %p After doing the kata quite a few times I find this step the best to take the recursive approach. With only 3 numbers it's easier to understand and quite simple. I don't feel comfortable with the fact that I could have refactored to a much simpler code like <code>'I' * self</code>. But after trying different approaches I find the recursive one the most understandable and readable.

  %li
    %p
      %u When extracting known roman equivalences and obtaining the closest one:
    %p This is the key step of my solution. I know the <code>select</code> chunk of code is quite complex the first time you see it. But I find it simpler than iterating over the equivalences or other approaches I tried. You find the equivalence that suits and apply it. Just that. It's exactly how you'd do it by hand:

    <div style="width: 500px; margin: 10px auto;">
    <code> 1978 = 1000 + 900 + 50 + 10 + 10 + 5 + 1 +1 +1 </code><br/>
    <code> 1978 =    M +  CM +  L  +   X +   X  + V + I + I + I</code>
    </div>

    %p At this point, with 5 lines of code and the equivalence hash, the solution works.

  %li
    %p
      %u When extracting the <code>RomanEquivalence</code> class:
    %p During the <a href="http://blog.dev.openfinance.es/2011/03/ii-coding-dojo/">Coding Dojo in Valencia</a> I showed this approach to <a href="http://twitter.com/#!/borillo" target="blank">@borillo</a>. He pointed out that the <code>select</code> chunk of code wasn't very understandable. It is not indeed.

    %p That's why I have pushed the implementation forward until extracting this complexity out of the <code>to_roman</code> method. That keeps the method to a higher level of abstraction that makes it much more clear.

    %p
      Although I'm increasing complexity by adding more elements (a second class) to the solution I think that the better understanding pays off (Laws of simple design: <i>maximize clarity</i> over <i>has fewer elements</i> ). What do you think?

    %p What I'm not so happy about is the refactoring process. I've tried to take small steps, but when I switch the implementation of <code>RomanEquivalence.closestTo(number)</code> to a factory method I feel I'm taking a huge leap forward. Maybe writing a separate spec for <code>RomanEquivalence</code> would have made me feel more comfortable.

%p Anyway, that's my solution. Now it's time to criticize it :-P. I have push it up to <a href="https://github.com/jacegu/Febrero-Roman-Numerals/tree/master/jacegu">a GitHub repository</a>.

%p I followed the suggestion made by <a href="http://alonsogarciapablo.com/">Pablo Alonso</a> on the <a href="http://jacegu.eu/aprendizaje/january-kata-string-calculator/">String Calculator Katacast</a> and used <a href="http://stephendeken.net/software/keycastr/">KeyCastr</a> to display the keys I'm pressing. (Thanks to <a href="http://twitter.com/#!/ecomba">@ecomba</a> for pointing me to it).
