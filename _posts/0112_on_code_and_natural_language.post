2012-01-09 09:00:00+02:00

On code and natural language

I gave a talk about the importance of code readability and how it is tightly related to code quality. But what is the readability level we should achieve?

%p
  On October I gave a talk (actually my first one at a big conference) at
  %a{href: 'http://conferencia2011.agile-spain.org', target: '_blank'}
  Conferencia Agile Spain 2011.
  <em>&ldquo;Por qué Cervantes programaba mejor que tú&rdquo;</em> (why Cervantes
  wrote better code than you) was the talk's title. It was a reflection about how
  code readability relates to other code quality principles and heuristics we use
  on a daily basis.

%p
  You can watch the talk right here. But be aware: it's in spanish. The slides are
  %a{href: 'http://www.slideshare.net/agilespain/cas11talk-111027063557phpapp01', target: '_blank', title: 'The slides of my talk on Slideshare'} available on Slideshare.

%iframe(src="http://player.vimeo.com/video/34459261" frameborder="0" class="vimeo")

%p
  The point I was trying to make was that <strong>the easiest way to write better
  code is to focus on readability</strong>.

%p
  But readability is subjective. This is also somthing I talked about. In fact in
  one of my last slides I put a example of the readability level I meant. It read
  exactly like de pseudo-code of the problem that was solved (slides
  %a{href: 'http://www.slideshare.net/agilespain/cas11talk-111027063557phpapp01/91', target: '_blank', title: 'pseudocode slide'} 91
  and
  %a{href: 'http://www.slideshare.net/agilespain/cas11talk-111027063557phpapp01/92', target: '_blank', title: 'actual code slide'} 92
  ). It was (or was intented to be) read like <strong>natural language</strong>.


%h2 The importance of naming

%blockquote
  One difference between a smart programmer and a professional programmer is that the
  professional understands that <strong>clarity is king</strong>. Professionals use their
  powers for good and write code that others can understand.
  %cite Clean Code, Robert C. Martin

%p
  On my first college year I had a subject called something like <i>Computer
  Software Foundations</i>. The teacher told us that our job will be, mainly, <strong>building
  levels of abstraction</strong>. That, unlike many other things I was taught there, was true.

%p
  When we write code we are abstracting the pieces, building the abstractions, needed to solve
  a certain problem. Those pieces, wether they are functions, methods, classes or variables,
  have names. They can be nouns, adjectives, verbs or even questions or short sentences. But
  they are what will make our code understandable or not. That's why naming is so important.


%h3 Ubiquitous Language

%p
  Those pices should be identifiable by anyone involved in the problem. And that doesn't mean
  only people who can actually read code. <strong>Anyone</strong>, from business to users,
  should be able to read a method name and tell what it is supossed to accomplish.

%p
  <strong>We must call things what users, clients or stakeholders call them</strong>. By listening
  and learning from what these people call things we should build an
  %a{href:'http://domaindrivendesign.org/node/132' , target: '_blank', title: 'Ubiquitous Language on Domain Driven Design'} Ubiquitous Language.



%h3 Mental mapping

%p
  One of the worst things we can do when we put names to things is <em>Mental Mapping</em>.
  This one is so bad it has its own section in Uncle Bob's
  %a{href: 'http://www.amazon.co.uk/gp/product/0132350882?ie=UTF8&amp;tag=yoyelsoft-21&amp;linkCode=as2&amp;camp=1634&amp;creative=6738&amp;creativeASIN=0132350882', target: '_blank', title: 'Clean Code on Amazon.co.uk'} Clean Code.

%p
  We are doing something wrong when we call something <i>foo</i> when we talk with users or
  clientes and this <i>foo</i> thing has a totally different name in our code. So what we
  do is <em>mapping</em> this name to the concept <i>foo</i>.

%p
  A really bad thing about mental mappings is that they have an expiration date: about two
  months after finishing a project nobody remembers them at all. So, when you revisit the
  code, you need to start asking what that thing named <i>blah</i> was.

%p
  We must <strong>avoid using a different name in the domain of the solution and the domain
  of the problem</strong> without a good reason (and usually there is none).



%h2 Natural language

%p
  Naming is the key factor if you want to write code that reads like natural language. It's the
  most important thing we should focus on. But we normaly name things <em>in isolation</em>. And,
  sometimes, when we put our pices together they just don't feel right.

%p
  Code that reads like prose isn't just based on naming. Even if we get the names right it might not
  <em>read right</em>. It might not be clear enough. It might sound weird or just plainly wrong.

%h3 It's a design tool

%p
  <strong>I have started to consider code that I can't make read as natural language a
  design smell</strong>. If you focus on good naming and name abstractions propperly and,
  when you put them together they are hard to understand, something is not right.

%p
  Usually that particular piece of code does too many things, or it's not at the right
  level of abstraction. It's code screaming at your face <em>refactor me, sir!</em>

%h3 The benefits

%p
  You should be wondering if it's worth it to put so much effort on writting code that
  reads like a book. Well, the answer is yes. It totally pays off:

%dl
  %dt Maximizes clarity
  %dd
    Clarity is the most importnat quality code should exhibit. And there is no thing
    a human being reads and understands more easily than prose.

  %dt Helps building pieces at the right level of abstraction
  %dd
    Code that reads like natural language helps you getting the design right. It will aid
    writting the right pieces at the right size.

  %dt Anybody can understand what's going on
  %dd
    If your code reads like natural language even non-coders will be able to understand it.
    If an end user reads it she can tell you what's wrong with it.

  %dt The bussines logic is right there
  %dd
    You won't have to go to other documents or places to read how a particular part of the
    system should behave. It's right there in plain English.
